#!/usr/bin/env python3
"""
Data Structures and Algorithms for CL 3, Project 1
See <https://https://dsacl3-2022.github.io/p1/> for detailed instructions.
Author:      Pun Ching Nei, Lorena Raichle, Kateryna Smykovska
Honor Code:  I pledge that this program represents my work.
We received help from: no one in designing and debugging our program.
"""

import json

from fsa import FSA, build_trie
from fst import FST

import numpy as np


def build_editfst(alphabet, counts):
    """Build an weighted FST instance that implements one-edit-distance operations.

    You should use the add_transition() method of the FST class
    to build an FST that returns all misspellings of a word
    with one-edit-distance away.

    The transition weight should be set based on the number of times
    particular edit operations were observed in the data (e.g.,
    spelling-data.txt). You are recommended to estimate (smoothed)
    probabilities for each edit operation, and use its logarithm.
    You are free to experiment with weighting schemes, but remember
    that the transduce() method of FST assumes additive weights.

    Arguments:
    ----
    alphabet    All letters that we should recognize
    counts      Counts generated by compute-weights.py
    """

    def nested_dict_values(d):
        for v in d.values():
            if isinstance(v, dict):
                yield from nested_dict_values(v)
            else:
                yield v

    def weight(insym, outsym, count):
        # calculate the log weight of corresponding amount
        if insym not in count:
            w = 1 / sum(nested_dict_values(count))
            return np.log(w)
        # smoothing for the weight
        elif outsym not in count[insym]:
            w = 1 / (sum(nested_dict_values(count[insym])) + len(count[insym].values()))
            return np.log(w)
        else:
            w = count[insym][outsym] / sum(nested_dict_values(count[insym]))
            return np.log(w)

    build = FST()
    for a in alphabet:
        # build transition with each alphabet
        build.add_transition(0, a, 0, a, weight(a, a, counts))
        build.add_transition(1, a, 1, a, weight(a, a, counts))
        # adding transition
        build.add_transition(0, "", 1, a, weight("", a, counts))
        # delete transition
        build.add_transition(0, a, 1, "", weight(a, "", counts))
        # add new transition when the new alphabet does not same as the old one
        for b in alphabet:
            if a != b:
                build.add_transition(0, a, 1, b, weight(a, b, counts))
    # add accepting state
    build.mark_accepting(1)
    return build


if __name__ == "__main__":

    # Example usage
    with open('lexicon.txt', 'rt') as f:
        words = f.read().strip().split()
    with open('spell-errors.json', 'rt') as f:
        errcount = json.loads(f.read())

    # Build the trie lexicon
    fsa = build_trie(words)
    # Minimize it
    fsa.minimize()
    # Convert it to an FST
    lexicon = FST.fromfsa(fsa)
    # Build the edit-distance FST
    letters = set([char for word in words for char in word])
    edits = build_editfst(letters, errcount)
    edits.write("edit")
    # Compose them
    spellfst = FST.compose_fst(lexicon, edits)
    # The above generates all spelling mistakes, we want the invert
    spellfst.invert()
    for sperr, w in sorted(spellfst.transduce("wort"), key=lambda x: x[1], reverse=True):
        print(sperr, w)
